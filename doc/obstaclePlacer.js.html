<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: maze/obstaclePlacer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: maze/obstaclePlacer.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * This module takes a matrix that represents a maze and returns a list of
 * cells where obstacles will be placed.
 * @module
 */
define([
  'lodash',
  './matrixMaze',
], function(_, matrixMaze) {
  'use strict';

  var exports = {

    /**
     * See if a object is in a list of objects.
     *
     * @private
     * @param {Array.&lt;Object>} listOfObjects A list of objects.
     * @param {Object} object The object that should be checked against the
     *   list.
     * @returns {boolean} True if `object` is equal to any of the objects in
     *   `listOfObjects`, false otherwise.
     */
    __objectIsInList: function(listOfObjects, object) {
      return _.some(listOfObjects, function(listObject) {
        return _.isEqual(listObject, object);
      });
    },

    /**
     * Check if any of the objects in `list2` are equal to the objects in
     * `list1`.
     *
     * @private
     * @param {Array.&lt;Object>} list1 A list of objects.
     * @param {Array.&lt;Object>} list2 A second list of objects.
     * @returns {boolean} True if any of the objects in `list1` is equal to any
     *   of the objects in `list2`.
     */
    __anyOfObjectAreInList: function(list1, list2) {
      return _.some(list2, function(cell) {
        return this.__objectIsInList(list1, cell);
      }.bind(this));
    },

    /**
     * Create and get coordinates for a number of obstacles. None of the
     * obstacles will be adjacent to each other.
     *
     * @param {Array.&lt;Array.&lt;Object>>} maze A matrix that represents a maze.
     * @param {boolean} maze.wall If it's a wall or floor.
     * @param {Array.&lt;Object>} ignoreCells A list of cells to ignore even if
     * they are floor cells.
     * @param {number} ignoreCells.x
     * @param {number} ignoreCells.y
     * @param {number} numberOfObstacles The maximum number of obstacles that
     *   will be placed into the maze.
     * @returns {Array.&lt;Object>} A list of cells where the obstacles should be
     *   placed. Each list element is an object with the attributes `x` and
     *   `y`.
     */
    place: function(maze, ignoreCells, numberOfObstacles) {
      var potentialCells = [];
      // Iterate through all the maze's cells and add store which ones are
      // floors and not in the `ignoreCells` list.
      _.forEach(maze, function(row, rowIndex) {
        _.forEach(maze, function(cell, cellIndex) {
          if (
            // The cell isn't a floor
            !maze[rowIndex][cellIndex].wall &amp;&amp;
            // And the cell isn't in the ignore list
            !this.__objectIsInList(ignoreCells, {y: rowIndex, x: cellIndex})
          ) {
            potentialCells.push({y: rowIndex, x: cellIndex});
          }
        }.bind(this));
      }.bind(this));

      // Shuffle the list so they are taken in random order
      potentialCells = _.shuffle(potentialCells);

      // Where the obstacles will be placed
      var obstacles = [];
      // Loop while there are potential cells left and it hasn't exceeded the
      // `numberOfObstacles` cap.
      for (
        var i = 0;
        obstacles.length &lt; numberOfObstacles &amp;&amp; i &lt; potentialCells.length;
        ++i
      ) {
        var cell = potentialCells[i];
        // Get all neighbor cells
        var neighborCells = matrixMaze.getCellNeighbors(maze, cell.y, cell.x);
        // Only add the cell as an obstacle if none of its neighbors are
        // already in the obstacles list
        if (!this.__anyOfObjectAreInList(obstacles, neighborCells)) {
          obstacles.push({y: cell.y, x: cell.x});
        }
      }
      return obstacles;
    },
  };

  return exports;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="Game.html">controller/Game</a></li><li><a href="Key.html">input/Key</a></li><li><a href="creator.html">maze/creator</a></li><li><a href="longestPathFinder.html">maze/longestPathFinder</a></li><li><a href="matrixMaze.html">maze/matrixMaze</a></li><li><a href="obstaclePlacer.html">maze/obstaclePlacer</a></li><li><a href="wallExtractor.html">maze/wallExtractor</a></li><li><a href="Game_.html">model/Game</a></li><li><a href="PriorityQueue.html">structs/PriorityQueue</a></li><li><a href="Game__.html">view/Game</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Fri Aug 29 2014 11:47:38 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
